// SPDX-License-Identifier: BSD-3-Clause-Clear
pragma solidity ^0.8.24;

import { FHE, euint8, euint32, externalEuint8 } from "@fhevm/solidity/lib/FHE.sol";
import { SepoliaConfig } from "@fhevm/solidity/config/ZamaConfig.sol";

/**
 * @title Infection Vulnerability Score (IVS) Contract
 * @author Sambit Sargam Ekalabya
 * @notice Implements a privacy-preserving infection vulnerability scoring system using Zama's fhEVM
 */
contract InfectionVulnerabilityScore is SepoliaConfig {
    
    // =====================================================
    // ERRORS
    // =====================================================
    
    error OnlyAdmin();
    error UserNotRegistered();
    error UserAlreadyRegistered();
    error CannotAddSelfAsContact();
    error InvalidAdminAddress();
    
    // =====================================================
    // CONSTANTS
    // =====================================================
    
    /// @notice Fixed-point scale factor for precise arithmetic (1e18)
    uint256 private constant FIXED_POINT_SCALE = 1e18;
    
    /// @notice Maximum safe value for fixed-point arithmetic to prevent overflow
    uint256 private constant MAX_SAFE_VALUE = type(uint256).max / FIXED_POINT_SCALE;
    
    /// @notice Admin address with special permissions
    address public admin;
    
    /// @notice Mapping of user ID to encrypted health status (0 = healthy, 1 = infected)
    /// @dev Using euint8 for boolean-like encrypted values (0 or 1)
    mapping(uint256 userId => euint8 healthStatus) private userHealthStatus;
    
    /// @notice Plaintext adjacency list: user ID to array of contact user IDs
    /// @dev Kept in plaintext to avoid encrypted conditionals in BFS traversal
    mapping(uint256 userId => uint256[] contacts) public userContacts;
    
    /// @notice Mapping of user ID to encrypted IVS score
    /// @dev Using euint32 to support fractional values with fixed-point arithmetic
    mapping(uint256 userId => euint32 ivsScore) private userIVSScore;
    
    /// @notice Array of all registered user IDs
    uint256[] public registeredUsers;
    
    /// @notice Mapping to check if a user is registered
    mapping(uint256 userId => bool registered) public isUserRegistered;
    
    /// @notice Plaintext visited set for BFS traversal to avoid double counting
    /// @dev Reset for each computeIVS call - used to prevent encrypted conditionals
    mapping(uint256 userId => bool isVisited) private visited;
    
    /// @notice Mapping to track which user requested each decryption
    mapping(uint256 requestId => uint256 userId) private decryptionRequestUser;
    
    /// @notice Mapping to track the type of data being decrypted
    mapping(uint256 requestId => string dataType) private decryptionRequestType;
    
    // =====================================================
    // EVENTS
    // =====================================================
    
    event UserRegistered(uint256 indexed userId);
    event ContactAdded(uint256 indexed userA, uint256 indexed userB);
    event HealthStatusUpdated(uint256 indexed userId);
    event IVSComputed(uint256 indexed dMax);
    event UserDeleted(uint256 indexed userId);
    event AllDataWiped();
    event DecryptionRequested(uint256 indexed requestId, uint256 indexed userId, string dataType);
    event DecryptionCompleted(
        uint256 indexed requestId, 
        uint256 indexed userId, 
        uint32 decryptedValue, 
        string dataType, 
        uint256 scaledValue
    );
    
    // =====================================================
    // MODIFIERS
    // =====================================================
    
    /// @notice Restricts function access to admin only
    modifier onlyAdmin() {
        if (msg.sender != admin) revert OnlyAdmin();
        _;
    }
    
    /// @notice Ensures user is registered before operations
    modifier onlyRegisteredUser(uint256 userId) {
        if (!isUserRegistered[userId]) revert UserNotRegistered();
        _;
    }
    
    // =====================================================
    // CONSTRUCTOR
    // =====================================================
    
    /// @notice Initializes the contract with the deployer as admin
    constructor() {
        admin = msg.sender;
    }
    
    // =====================================================
    // USER REGISTRATION & MANAGEMENT
    // =====================================================
    
    /// @notice Allows a user to register in the system
    /// @param userId The unique identifier for the user
    function registerUser(uint256 userId) external {
        if (isUserRegistered[userId]) revert UserAlreadyRegistered();
        
        isUserRegistered[userId] = true;
        registeredUsers.push(userId);
        
        // Initialize encrypted health status to 0 (healthy)
        userHealthStatus[userId] = FHE.asEuint8(0);
        FHE.allowThis(userHealthStatus[userId]);
        
        // Initialize encrypted IVS score to 0
        userIVSScore[userId] = FHE.asEuint32(0);
        FHE.allowThis(userIVSScore[userId]);
        
        emit UserRegistered(userId);
    }
    
    /// @notice Adds a bidirectional contact between two users
    /// @param userA First user ID
    /// @param userB Second user ID
    /// @dev Contacts are stored in plaintext to enable efficient BFS traversal
    function addContact(uint256 userA, uint256 userB) 
        external 
        onlyRegisteredUser(userA) 
        onlyRegisteredUser(userB) 
    {
        if (userA == userB) revert CannotAddSelfAsContact();
        
        // Add bidirectional contact
        userContacts[userA].push(userB);
        userContacts[userB].push(userA);
        
        emit ContactAdded(userA, userB);
    }
    
    /// @notice Sets encrypted health status for a user
    /// @param userId The user ID
    /// @param encStatus Encrypted health status (0 = healthy, 1 = infected)
    /// @param inputProof Proof for the encrypted input
    function setHealthStatus(
        uint256 userId, 
        externalEuint8 encStatus, 
        bytes calldata inputProof
    ) external onlyRegisteredUser(userId) {
        // Convert external encrypted input to internal encrypted type
        euint8 encryptedStatus = FHE.fromExternal(encStatus, inputProof);
        
        // Store the encrypted health status
        userHealthStatus[userId] = encryptedStatus;
        
        // Grant permissions for future operations
        FHE.allowThis(userHealthStatus[userId]);
        FHE.allow(userHealthStatus[userId], msg.sender);
        
        emit HealthStatusUpdated(userId);
    }
    
    // =====================================================
    // IVS COMPUTATION (ALGORITHM 4 - LEVEL-SYNCHRONOUS BFS)
    // =====================================================
    
    /// @notice Computes IVS scores for all users using level-synchronous BFS propagation
    /// @param dMax Maximum depth for propagation
    /// @dev Implements Algorithm 4 with encrypted operations and plaintext visited tracking
    function computeIVS(uint256 dMax) external onlyAdmin {
        // Reset visited set for this computation
        _resetVisitedSet();
        
        // Initialize all IVS scores to 0
        for (uint256 i = 0; i < registeredUsers.length; i++) {
            uint256 userId = registeredUsers[i];
            userIVSScore[userId] = FHE.asEuint32(0);
            FHE.allowThis(userIVSScore[userId]);
        }
        
        // For each user, perform BFS propagation
        for (uint256 i = 0; i < registeredUsers.length; i++) {
            uint256 sourceUserId = registeredUsers[i];
            _propagateFromUser(sourceUserId, dMax);
            _resetVisitedSet(); // Reset for next user
        }
        
        emit IVSComputed(dMax);
    }
    
    /// @notice Internal function to propagate infection risk from a source user
    /// @param sourceUserId The source user to propagate from
    /// @param dMax Maximum propagation depth
    /// @dev Implements level-synchronous BFS with encrypted health status weighting
    function _propagateFromUser(uint256 sourceUserId, uint256 dMax) private {
        // Initialize BFS queue for current level and next level
        uint256[] memory currentLevel = new uint256[](1);
        currentLevel[0] = sourceUserId;
        visited[sourceUserId] = true;
        
        // Process each depth level
        for (uint256 depth = 0; depth <= dMax && currentLevel.length > 0; depth++) {
            uint256[] memory nextLevel = new uint256[](0);
            
            // Process all users at current depth
            for (uint256 i = 0; i < currentLevel.length; i++) {
                uint256 currentUserId = currentLevel[i];
                
                // Calculate weight: 1/2^(depth+1) using precise fixed-point arithmetic
                uint256 fixedPointWeight = _calculateWeight(depth);
                uint32 weight = _scaleWeightForFHE(fixedPointWeight);
                
                // Add weighted contribution to IVS score
                // IVS[sourceUserId] += weight * healthStatus[currentUserId]
                euint32 weightedContribution = FHE.mul(
                    userHealthStatus[currentUserId], 
                    FHE.asEuint32(weight)
                );
                
                userIVSScore[sourceUserId] = FHE.add(
                    userIVSScore[sourceUserId], 
                    weightedContribution
                );
                FHE.allowThis(userIVSScore[sourceUserId]);
                
                // Add unvisited contacts to next level
                uint256[] memory contacts = userContacts[currentUserId];
                for (uint256 j = 0; j < contacts.length; j++) {
                    uint256 contactId = contacts[j];
                    if (!visited[contactId] && isUserRegistered[contactId]) {
                        visited[contactId] = true;
                        nextLevel = _appendToArray(nextLevel, contactId);
                    }
                }
            }
            
            currentLevel = nextLevel;
        }
    }
    
    /// @notice Calculates weight for given depth: 1/2^(depth+1) using fixed-point arithmetic
    /// @param depth The current depth in BFS traversal
    /// @return weight The weight as uint256 (scaled by FIXED_POINT_SCALE)
    /// @dev Implements precise fractional weight calculation with overflow protection
    function _calculateWeight(uint256 depth) private pure returns (uint256 weight) {
        // Calculate 2^(depth+1) with overflow protection
        uint256 exponent = depth + 1;
        if (exponent >= 256) return 0; // Prevent overflow, weight becomes negligible
        
        uint256 divisor = 2 ** exponent;
        
        // Calculate weight = FIXED_POINT_SCALE / divisor
        // This gives us a fixed-point representation of 1/2^(depth+1)
        weight = FIXED_POINT_SCALE / divisor;
        
        return weight;
    }
    
    /// @notice Converts fixed-point weight to uint32 for FHE operations
    /// @param fixedPointWeight The weight in fixed-point format
    /// @return scaledWeight The weight scaled to fit uint32 range
    /// @dev Scales down fixed-point weight to prevent uint32 overflow while preserving precision
    function _scaleWeightForFHE(uint256 fixedPointWeight) private pure returns (uint32 scaledWeight) {
        // Scale down by 1e14 to fit in uint32 while keeping 4 decimal places precision
        // This gives us weights in range 0-10000 representing 0.0000-1.0000
        scaledWeight = uint32(fixedPointWeight / 1e14);
        
        // Ensure we don't overflow uint32
        if (scaledWeight > type(uint32).max) {
            scaledWeight = type(uint32).max;
        }
        
        return scaledWeight;
    }
    
    /// @notice Utility function to append element to dynamic array
    /// @param arr The array to append to
    /// @param element The element to append
    /// @return newArr The new array with element appended
    function _appendToArray(uint256[] memory arr, uint256 element) 
        private 
        pure 
        returns (uint256[] memory newArr) 
    {
        newArr = new uint256[](arr.length + 1);
        for (uint256 i = 0; i < arr.length; i++) {
            newArr[i] = arr[i];
        }
        newArr[arr.length] = element;
    }
    
    /// @notice Resets the visited set for BFS traversal
    function _resetVisitedSet() private {
        for (uint256 i = 0; i < registeredUsers.length; i++) {
            visited[registeredUsers[i]] = false;
        }
    }
    
    // =====================================================
    // IVS SCORE RETRIEVAL
    // =====================================================
    
    /// @notice Returns encrypted IVS score for public access
    /// @param userId The user ID to get IVS score for
    /// @return The encrypted IVS score
    function getEncryptedIVS(uint256 userId) 
        external 
        view 
        onlyRegisteredUser(userId) 
        returns (euint32) 
    {
        return userIVSScore[userId];
    }
    
    /// @notice Requests decryption of IVS score (admin only)
    /// @param userId The user ID to decrypt IVS score for
    function getDecryptedIVS(uint256 userId) 
        external 
        onlyAdmin 
        onlyRegisteredUser(userId) 
        returns (uint256 requestId)
    {
        // Prepare ciphertext for decryption
        bytes32[] memory cipherTexts = new bytes32[](1);
        cipherTexts[0] = FHE.toBytes32(userIVSScore[userId]);
        
        // Request async decryption from FHEVM backend
        requestId = FHE.requestDecryption(
            cipherTexts,
            this.callbackDecryptedIVS.selector
        );
        
        // Store which user this request is for
        decryptionRequestUser[requestId] = userId;
        decryptionRequestType[requestId] = "ivs";
        
        emit DecryptionRequested(requestId, userId, "ivs");
        return requestId;
    }

    /// @notice Requests decryption of health status (admin only)
    /// @param userId The user ID to decrypt health status for
    function getDecryptedHealthStatus(uint256 userId) 
        external 
        onlyAdmin 
        onlyRegisteredUser(userId) 
        returns (uint256 requestId)
    {
        // Prepare ciphertext for decryption
        bytes32[] memory cipherTexts = new bytes32[](1);
        cipherTexts[0] = FHE.toBytes32(userHealthStatus[userId]);
        
        // Request async decryption from FHEVM backend
        requestId = FHE.requestDecryption(
            cipherTexts,
            this.callbackDecryptedHealthStatus.selector
        );
        
        // Store which user this request is for
        decryptionRequestUser[requestId] = userId;
        decryptionRequestType[requestId] = "health";
        
        emit DecryptionRequested(requestId, userId, "health");
        return requestId;
    }
    
    /// @notice Callback function for IVS decryption results
    /// @param requestId The decryption request ID
    /// @param cleartexts ABI-encoded decrypted values
    /// @param decryptionProof KMS signatures and extra data for verification
    /// @dev Implements proper signature verification as per Zama documentation
    /// @dev Emits decrypted value in event - does not store on-chain for privacy
    function callbackDecryptedIVS(
        uint256 requestId, 
        bytes memory cleartexts, 
        bytes memory decryptionProof
    ) external {
        // Verify signatures to prevent unauthorized calls
        FHE.checkSignatures(requestId, cleartexts, decryptionProof);
        
        // Decode the decrypted IVS score from cleartexts
        (uint32 decryptedIVS) = abi.decode(cleartexts, (uint32));
        
        // Get the user ID for this request
        uint256 userId = decryptionRequestUser[requestId];
        
        // Calculate scaled value (convert from 10000-scale back to meaningful decimal)
        // This converts 5000 -> 0.5, 2500 -> 0.25, etc.
        uint256 scaledValue = (decryptedIVS) / 10000; // Multiply by 1000 to get 3 decimal places
        
        // Emit the decrypted value (off-chain listeners can capture this)
        emit DecryptionCompleted(requestId, userId, decryptedIVS, "ivs", scaledValue);
        
        // Clean up the request tracking (optional - saves gas for future requests)
        delete decryptionRequestUser[requestId];
        delete decryptionRequestType[requestId];
    }

    /// @notice Callback function for health status decryption results
    /// @param requestId The decryption request ID
    /// @param cleartexts ABI-encoded decrypted values
    /// @param decryptionProof KMS signatures and extra data for verification
    /// @dev Implements proper signature verification as per Zama documentation
    /// @dev Emits decrypted value in event - does not store on-chain for privacy
    function callbackDecryptedHealthStatus(
        uint256 requestId, 
        bytes memory cleartexts, 
        bytes memory decryptionProof
    ) external {
        // Verify signatures to prevent unauthorized calls
        FHE.checkSignatures(requestId, cleartexts, decryptionProof);
        
        // Decode the decrypted health status from cleartexts
        (uint8 decryptedHealthStatus) = abi.decode(cleartexts, (uint8));
        
        // Get the user ID for this request
        uint256 userId = decryptionRequestUser[requestId];
        
        // For health status, scaled value is the same as raw (0 or 1)
        uint256 scaledValue = decryptedHealthStatus;
        
        // Emit the decrypted value (off-chain listeners can capture this)
        emit DecryptionCompleted(requestId, userId, decryptedHealthStatus, "health", scaledValue);
        
        // Clean up the request tracking (optional - saves gas for future requests)
        delete decryptionRequestUser[requestId];
        delete decryptionRequestType[requestId];
    }
    
    // =====================================================
    // ADMIN FUNCTIONS
    // =====================================================
    
    /// @notice Deletes a specific user and all associated data
    /// @param userId The user ID to delete
    function deleteUser(uint256 userId) external onlyAdmin onlyRegisteredUser(userId) {
        // Remove from registered users array
        for (uint256 i = 0; i < registeredUsers.length; i++) {
            if (registeredUsers[i] == userId) {
                registeredUsers[i] = registeredUsers[registeredUsers.length - 1];
                registeredUsers.pop();
                break;
            }
        }
        
        // Clear user data
        isUserRegistered[userId] = false;
        delete userContacts[userId];
        
        // Clear encrypted data (reset to zero)
        userHealthStatus[userId] = FHE.asEuint8(0);
        userIVSScore[userId] = FHE.asEuint32(0);
        
        // Remove user from all other users' contact lists
        for (uint256 i = 0; i < registeredUsers.length; i++) {
            uint256 otherUserId = registeredUsers[i];
            uint256[] storage contacts = userContacts[otherUserId];
            
            for (uint256 j = 0; j < contacts.length; j++) {
                if (contacts[j] == userId) {
                    contacts[j] = contacts[contacts.length - 1];
                    contacts.pop();
                    break;
                }
            }
        }
        
        emit UserDeleted(userId);
    }
    
    /// @notice Wipes all user data and resets the contract state
    function wipeAllData() external onlyAdmin {
        // Clear all registered users
        for (uint256 i = 0; i < registeredUsers.length; i++) {
            uint256 userId = registeredUsers[i];
            isUserRegistered[userId] = false;
            delete userContacts[userId];
            
            // Reset encrypted data
            userHealthStatus[userId] = FHE.asEuint8(0);
            userIVSScore[userId] = FHE.asEuint32(0);
        }
        
        // Clear the registered users array
        delete registeredUsers;
        
        emit AllDataWiped();
    }
    
    /// @notice Changes the admin address
    /// @param newAdmin The new admin address
    function changeAdmin(address newAdmin) external onlyAdmin {
        if (newAdmin == address(0)) revert InvalidAdminAddress();
        admin = newAdmin;
    }
    
    // =====================================================
    // VIEW FUNCTIONS
    // =====================================================
    
    /// @notice Gets the list of contacts for a user
    /// @param userId The user ID
    /// @return Array of contact user IDs
    function getUserContacts(uint256 userId) 
        external 
        view 
        onlyRegisteredUser(userId) 
        returns (uint256[] memory) 
    {
        return userContacts[userId];
    }
    
    /// @notice Gets the total number of registered users
    /// @return The number of registered users
    function getTotalUsers() external view returns (uint256) {
        return registeredUsers.length;
    }
    
    /// @notice Gets all registered user IDs
    /// @return Array of all registered user IDs
    function getAllUsers() external view returns (uint256[] memory) {
        return registeredUsers;
    }
    
    /// @notice Gets encrypted health status for a user (if authorized)
    /// @param userId The user ID
    /// @return The encrypted health status
    function getEncryptedHealthStatus(uint256 userId) 
        external 
        view 
        onlyRegisteredUser(userId) 
        returns (euint8) 
    {
        return userHealthStatus[userId];
    }
}