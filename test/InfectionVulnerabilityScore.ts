import { expect } from "chai";
import { ethers } from "hardhat";
import { HardhatEthersSigner } from "@nomicfoundation/hardhat-ethers/signers";
import { InfectionVulnerabilityScore } from "../types";

describe("InfectionVulnerabilityScore", function () {
  let contract: InfectionVulnerabilityScore;
  let user1: HardhatEthersSigner;
  let _user2: HardhatEthersSigner;
  let _user3: HardhatEthersSigner;

  beforeEach(async function () {
    const [admin, userSigner1, _user2, _user3] = await ethers.getSigners();
    user1 = userSigner1;

    const ContractFactory = await ethers.getContractFactory("InfectionVulnerabilityScore");
    contract = await ContractFactory.connect(admin).deploy() as InfectionVulnerabilityScore;
    await contract.waitForDeployment();
  });

  describe("User Registration", function () {
    it("Should register a user successfully", async function () {
      await expect(contract.registerUser(1))
        .to.emit(contract, "UserRegistered")
        .withArgs(1);

      expect(await contract.isUserRegistered(1)).to.be.true;
      expect(await contract.getTotalUsers()).to.equal(1);
    });

    it("Should not allow duplicate registration", async function () {
      await contract.registerUser(1);
      
      await expect(contract.registerUser(1))
        .to.be.revertedWithCustomError(contract, "UserAlreadyRegistered");
    });
  });

  describe("Contact Management", function () {
    beforeEach(async function () {
      await contract.registerUser(1);
      await contract.registerUser(2);
      await contract.registerUser(3);
    });

    it("Should add contacts between users", async function () {
      await expect(contract.addContact(1, 2))
        .to.emit(contract, "ContactAdded")
        .withArgs(1, 2);

      const user1Contacts = await contract.getUserContacts(1);
      const user2Contacts = await contract.getUserContacts(2);

      expect(user1Contacts).to.include(2n);
      expect(user2Contacts).to.include(1n);
    });

    it("Should not allow self-contact", async function () {
      await expect(contract.addContact(1, 1))
        .to.be.revertedWithCustomError(contract, "CannotAddSelfAsContact");
    });

    it("Should not allow contact with unregistered user", async function () {
      await expect(contract.addContact(1, 999))
        .to.be.revertedWithCustomError(contract, "UserNotRegistered");
    });
  });

  describe("Health Status Management", function () {
    beforeEach(async function () {
      await contract.registerUser(1);
    });

    it("Should set health status with proper encryption", async function () {
      // Note: In a real test, you would need to properly encrypt the input
      // using the FHEVM SDK. This is a placeholder for the test structure.
      
      // Mock encrypted input - in reality, this would be properly encrypted
      // const mockEncryptedStatus = ethers.encodeBytes32String("mock_encrypted");
      // const mockProof = ethers.toUtf8Bytes("mock_proof");

      // This test would need proper FHEVM SDK integration to work
      // await expect(contract.setHealthStatus(1, mockEncryptedStatus, mockProof))
      //   .to.emit(contract, "HealthStatusUpdated")
      //   .withArgs(1);
    });
  });

  describe("Admin Functions", function () {
    beforeEach(async function () {
      await contract.registerUser(1);
      await contract.registerUser(2);
      await contract.addContact(1, 2);
    });

    it("Should allow admin to delete user", async function () {
      await expect(contract.deleteUser(1))
        .to.emit(contract, "UserDeleted")
        .withArgs(1);

      expect(await contract.isUserRegistered(1)).to.be.false;
      expect(await contract.getTotalUsers()).to.equal(1);
    });

    it("Should allow admin to wipe all data", async function () {
      await expect(contract.wipeAllData())
        .to.emit(contract, "AllDataWiped");

      expect(await contract.getTotalUsers()).to.equal(0);
      expect(await contract.isUserRegistered(1)).to.be.false;
      expect(await contract.isUserRegistered(2)).to.be.false;
    });

    it("Should not allow non-admin to call admin functions", async function () {
      await expect(contract.connect(user1).deleteUser(1))
        .to.be.revertedWithCustomError(contract, "OnlyAdmin");

      await expect(contract.connect(user1).wipeAllData())
        .to.be.revertedWithCustomError(contract, "OnlyAdmin");
    });

    it("Should allow admin to change admin address", async function () {
      await contract.changeAdmin(user1.address);
      expect(await contract.admin()).to.equal(user1.address);
    });
  });

  describe("IVS Computation", function () {
    beforeEach(async function () {
      // Set up the 5-user example from the contract comments
      await contract.registerUser(1);
      await contract.registerUser(2);
      await contract.registerUser(3);
      await contract.registerUser(4);
      await contract.registerUser(5);

      // Add contacts as per example
      await contract.addContact(1, 2);
      await contract.addContact(1, 3);
      await contract.addContact(2, 4);
      await contract.addContact(3, 5);
    });

    it("Should compute IVS scores for all users", async function () {
      const Dmax = 2;
      
      await expect(contract.computeIVS(Dmax))
        .to.emit(contract, "IVSComputed")
        .withArgs(Dmax);

      // Verify that encrypted IVS scores are available
      // Note: We can't directly verify the encrypted values without decryption
      const user1IVS = await contract.getEncryptedIVS(1);
      const user2IVS = await contract.getEncryptedIVS(2);
      
      // These are encrypted values, so we can only verify they exist
      expect(user1IVS).to.not.be.undefined;
      expect(user2IVS).to.not.be.undefined;
    });

    it("Should only allow admin to compute IVS", async function () {
      await expect(contract.connect(user1).computeIVS(2))
        .to.be.revertedWithCustomError(contract, "OnlyAdmin");
    });
  });

  describe("View Functions", function () {
    beforeEach(async function () {
      await contract.registerUser(1);
      await contract.registerUser(2);
      await contract.addContact(1, 2);
    });

    it("Should return user contacts", async function () {
      const contacts = await contract.getUserContacts(1);
      expect(contacts).to.include(2n);
    });

    it("Should return all registered users", async function () {
      const allUsers = await contract.getAllUsers();
      expect(allUsers).to.include(1n);
      expect(allUsers).to.include(2n);
      expect(allUsers.length).to.equal(2);
    });

    it("Should return total user count", async function () {
      expect(await contract.getTotalUsers()).to.equal(2);
    });
  });
});

/*
 * Additional Test Notes:
 * 
 * 1. Encryption Testing:
 *    - Real tests would require FHEVM SDK integration for proper encryption
 *    - Input values need to be encrypted client-side before sending to contract
 *    - Proof generation requires proper FHEVM setup
 * 
 * 2. Decryption Testing:
 *    - Decryption callbacks require FHEVM backend simulation
 *    - Signature verification needs proper key setup
 *    - Async nature requires careful test orchestration
 * 
 * 3. IVS Computation Testing:
 *    - Expected values depend on fixed-point arithmetic implementation
 *    - Current integer weights may need scaling factor verification
 *    - BFS algorithm correctness can be verified through contact traversal
 * 
 * 4. Performance Testing:
 *    - Large graph traversal performance
 *    - Gas consumption for encrypted operations
 *    - Memory usage with large contact networks
 * 
 * 5. Security Testing:
 *    - Access control verification
 *    - Signature validation in callbacks
 *    - Proper permission handling for encrypted data
 */