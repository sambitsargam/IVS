import { expect } from "chai";
import { ethers } from "hardhat";
import { HardhatEthersSigner } from "@nomicfoundation/hardhat-ethers/signers";
import { InfectionVulnerabilityScore } from "../types";

describe("InfectionVulnerabilityScore - Comprehensive Tests", function () {
  let contract: InfectionVulnerabilityScore;
  let admin: HardhatEthersSigner;
  let user1: HardhatEthersSigner;
  let user2: HardhatEthersSigner;
  let user3: HardhatEthersSigner;
  let nonAdmin: HardhatEthersSigner;

  beforeEach(async function () {
    [admin, user1, user2, user3, nonAdmin] = await ethers.getSigners();

    const ContractFactory = await ethers.getContractFactory("InfectionVulnerabilityScore");
    contract = await ContractFactory.connect(admin).deploy() as InfectionVulnerabilityScore;
    await contract.waitForDeployment();
  });

  describe("Contract Initialization", function () {
    it("Should set the deployer as admin", async function () {
      expect(await contract.admin()).to.equal(admin.address);
    });

    it("Should start with zero users", async function () {
      expect(await contract.getTotalUsers()).to.equal(0);
      const allUsers = await contract.getAllUsers();
      expect(allUsers.length).to.equal(0);
    });
  });

  describe("User Registration System", function () {
    it("Should register multiple users successfully", async function () {
      const userIds = [1, 2, 3, 4, 5];
      
      for (const userId of userIds) {
        await expect(contract.registerUser(userId))
          .to.emit(contract, "UserRegistered")
          .withArgs(userId);
        
        expect(await contract.isUserRegistered(userId)).to.be.true;
      }
      
      expect(await contract.getTotalUsers()).to.equal(userIds.length);
      
      const allUsers = await contract.getAllUsers();
      expect(allUsers.length).to.equal(userIds.length);
      for (const userId of userIds) {
        expect(allUsers).to.include(BigInt(userId));
      }
    });

    it("Should prevent duplicate registration", async function () {
      await contract.registerUser(1);
      
      await expect(contract.registerUser(1))
        .to.be.revertedWithCustomError(contract, "UserAlreadyRegistered");
    });

    it("Should initialize encrypted data for new users", async function () {
      await contract.registerUser(1);
      
      // Should be able to get encrypted health status and IVS score
      const encryptedHealth = await contract.getEncryptedHealthStatus(1);
      const encryptedIVS = await contract.getEncryptedIVS(1);
      
      expect(encryptedHealth).to.not.equal(ethers.ZeroHash);
      expect(encryptedIVS).to.not.equal(ethers.ZeroHash);
    });
  });

  describe("Contact Management System", function () {
    beforeEach(async function () {
      // Register test users
      await contract.registerUser(1);
      await contract.registerUser(2);
      await contract.registerUser(3);
      await contract.registerUser(4);
      await contract.registerUser(5);
    });

    it("Should create bidirectional contacts", async function () {
      await expect(contract.addContact(1, 2))
        .to.emit(contract, "ContactAdded")
        .withArgs(1, 2);

      const user1Contacts = await contract.getUserContacts(1);
      const user2Contacts = await contract.getUserContacts(2);

      expect(user1Contacts).to.include(2n);
      expect(user2Contacts).to.include(1n);
    });

    it("Should build complex contact networks", async function () {
      // Create the network from contract example:
      // User 1: [2, 3], User 2: [1, 4], User 3: [1, 5], User 4: [2], User 5: [3]
      await contract.addContact(1, 2);
      await contract.addContact(1, 3);
      await contract.addContact(2, 4);
      await contract.addContact(3, 5);

      // Verify the network structure
      const user1Contacts = await contract.getUserContacts(1);
      const user2Contacts = await contract.getUserContacts(2);
      const user3Contacts = await contract.getUserContacts(3);
      const user4Contacts = await contract.getUserContacts(4);
      const user5Contacts = await contract.getUserContacts(5);

      expect(user1Contacts).to.deep.equal([2n, 3n]);
      expect(user2Contacts).to.deep.equal([1n, 4n]);
      expect(user3Contacts).to.deep.equal([1n, 5n]);
      expect(user4Contacts).to.deep.equal([2n]);
      expect(user5Contacts).to.deep.equal([3n]);
    });

    it("Should prevent self-contacts", async function () {
      await expect(contract.addContact(1, 1))
        .to.be.revertedWithCustomError(contract, "CannotAddSelfAsContact");
    });

    it("Should prevent contacts with unregistered users", async function () {
      await expect(contract.addContact(1, 999))
        .to.be.revertedWithCustomError(contract, "UserNotRegistered");
      
      await expect(contract.addContact(999, 1))
        .to.be.revertedWithCustomError(contract, "UserNotRegistered");
    });
  });

  describe("Admin Access Control", function () {
    beforeEach(async function () {
      await contract.registerUser(1);
      await contract.registerUser(2);
    });

    it("Should allow only admin to compute IVS", async function () {
      await expect(contract.connect(nonAdmin).computeIVS(2))
        .to.be.revertedWithCustomError(contract, "OnlyAdmin");
      
      // Admin should be able to call it
      await expect(contract.connect(admin).computeIVS(2))
        .to.emit(contract, "IVSComputed")
        .withArgs(2);
    });

    it("Should allow only admin to request decryption", async function () {
      await expect(contract.connect(nonAdmin).getDecryptedIVS(1))
        .to.be.revertedWithCustomError(contract, "OnlyAdmin");
    });

    it("Should allow only admin to delete users", async function () {
      await expect(contract.connect(nonAdmin).deleteUser(1))
        .to.be.revertedWithCustomError(contract, "OnlyAdmin");
    });

    it("Should allow only admin to wipe all data", async function () {
      await expect(contract.connect(nonAdmin).wipeAllData())
        .to.be.revertedWithCustomError(contract, "OnlyAdmin");
    });

    it("Should allow admin to change admin address", async function () {
      await contract.changeAdmin(user1.address);
      expect(await contract.admin()).to.equal(user1.address);
      
      // Old admin should no longer have access
      await expect(contract.connect(admin).computeIVS(2))
        .to.be.revertedWithCustomError(contract, "OnlyAdmin");
      
      // New admin should have access
      await expect(contract.connect(user1).computeIVS(2))
        .to.emit(contract, "IVSComputed")
        .withArgs(2);
    });

    it("Should prevent setting admin to zero address", async function () {
      await expect(contract.changeAdmin(ethers.ZeroAddress))
        .to.be.revertedWithCustomError(contract, "InvalidAdminAddress");
    });
  });

  describe("IVS Computation Algorithm", function () {
    beforeEach(async function () {
      // Set up the 5-user example from the contract comments
      await contract.registerUser(1);
      await contract.registerUser(2);
      await contract.registerUser(3);
      await contract.registerUser(4);
      await contract.registerUser(5);

      // Create the network: User 1: [2, 3], User 2: [1, 4], User 3: [1, 5], User 4: [2], User 5: [3]
      await contract.addContact(1, 2);
      await contract.addContact(1, 3);
      await contract.addContact(2, 4);
      await contract.addContact(3, 5);
    });

    it("Should compute IVS for different depth values", async function () {
      const depthValues = [0, 1, 2, 3, 5];
      
      for (const dMax of depthValues) {
        await expect(contract.computeIVS(dMax))
          .to.emit(contract, "IVSComputed")
          .withArgs(dMax);
      }
    });

    it("Should update IVS scores when recomputed", async function () {
      // Initial computation
      await contract.computeIVS(2);
      
      const initialIVS = await contract.getEncryptedIVS(1);
      
      // Recompute with different depth
      await contract.computeIVS(1);
      
      const newIVS = await contract.getEncryptedIVS(1);
      
      // Encrypted values should be different (assuming some randomness in encryption)
      // In a real test with actual FHE, we'd decrypt and compare the values
      expect(newIVS).to.not.equal(ethers.ZeroHash);
      expect(initialIVS).to.not.equal(ethers.ZeroHash);
    });

    it("Should handle edge cases gracefully", async function () {
      // Test with single user
      await contract.wipeAllData();
      await contract.registerUser(1);
      
      await expect(contract.computeIVS(2))
        .to.emit(contract, "IVSComputed")
        .withArgs(2);
      
      // Test with no users
      await contract.wipeAllData();
      
      await expect(contract.computeIVS(2))
        .to.emit(contract, "IVSComputed")
        .withArgs(2);
    });
  });

  describe("Decryption Request System", function () {
    beforeEach(async function () {
      await contract.registerUser(1);
      await contract.registerUser(2);
      await contract.computeIVS(2);
    });

    it("Should request decryption and emit proper events", async function () {
      const tx = await contract.getDecryptedIVS(1);
      const receipt = await tx.wait();
      
      expect(receipt).to.not.be.null;
      
      // Should emit DecryptionRequested event
      const events = receipt!.logs.filter(log => {
        try {
          const parsed = contract.interface.parseLog(log);
          return parsed?.name === 'DecryptionRequested';
        } catch {
          return false;
        }
      });
      
      expect(events.length).to.equal(1);
      
      const event = contract.interface.parseLog(events[0]);
      expect(event?.args[1]).to.equal(1n); // userId
    });

    it("Should return request ID for tracking", async function () {
      const tx = await contract.getDecryptedIVS(1);
      const receipt = await tx.wait();
      
      // The function should return a request ID
      expect(receipt).to.not.be.null;
    });

    it("Should prevent decryption of unregistered users", async function () {
      await expect(contract.getDecryptedIVS(999))
        .to.be.revertedWithCustomError(contract, "UserNotRegistered");
    });
  });

  describe("User Deletion and Data Management", function () {
    beforeEach(async function () {
      // Create a network
      await contract.registerUser(1);
      await contract.registerUser(2);
      await contract.registerUser(3);
      await contract.addContact(1, 2);
      await contract.addContact(2, 3);
      await contract.addContact(1, 3);
    });

    it("Should remove user from all contact lists when deleted", async function () {
      // Before deletion, verify contacts
      const user2Contacts = await contract.getUserContacts(2);
      const user3Contacts = await contract.getUserContacts(3);
      expect(user2Contacts).to.include(1n);
      expect(user3Contacts).to.include(1n);
      
      // Delete user 1
      await expect(contract.deleteUser(1))
        .to.emit(contract, "UserDeleted")
        .withArgs(1);
      
      // After deletion, user 1 should be removed from other users' contact lists
      const user2ContactsAfter = await contract.getUserContacts(2);
      const user3ContactsAfter = await contract.getUserContacts(3);
      expect(user2ContactsAfter).to.not.include(1n);
      expect(user3ContactsAfter).to.not.include(1n);
      
      // User 1 should no longer be registered
      expect(await contract.isUserRegistered(1)).to.be.false;
      expect(await contract.getTotalUsers()).to.equal(2);
    });

    it("Should wipe all data completely", async function () {
      // Verify initial state
      expect(await contract.getTotalUsers()).to.equal(3);
      
      // Wipe all data
      await expect(contract.wipeAllData())
        .to.emit(contract, "AllDataWiped");
      
      // Verify everything is cleaned
      expect(await contract.getTotalUsers()).to.equal(0);
      expect(await contract.isUserRegistered(1)).to.be.false;
      expect(await contract.isUserRegistered(2)).to.be.false;
      expect(await contract.isUserRegistered(3)).to.be.false;
      
      const allUsers = await contract.getAllUsers();
      expect(allUsers.length).to.equal(0);
    });
  });

  describe("View Functions", function () {
    beforeEach(async function () {
      await contract.registerUser(1);
      await contract.registerUser(2);
      await contract.registerUser(3);
      await contract.addContact(1, 2);
      await contract.addContact(2, 3);
    });

    it("Should return correct user information", async function () {
      expect(await contract.getTotalUsers()).to.equal(3);
      
      const allUsers = await contract.getAllUsers();
      expect(allUsers).to.deep.equal([1n, 2n, 3n]);
      
      const user1Contacts = await contract.getUserContacts(1);
      expect(user1Contacts).to.deep.equal([2n]);
      
      const user2Contacts = await contract.getUserContacts(2);
      expect(user2Contacts).to.deep.equal([1n, 3n]);
    });

    it("Should prevent access to unregistered user data", async function () {
      await expect(contract.getUserContacts(999))
        .to.be.revertedWithCustomError(contract, "UserNotRegistered");
      
      await expect(contract.getEncryptedHealthStatus(999))
        .to.be.revertedWithCustomError(contract, "UserNotRegistered");
      
      await expect(contract.getEncryptedIVS(999))
        .to.be.revertedWithCustomError(contract, "UserNotRegistered");
    });
  });

  describe("Weight Calculation Functions", function () {
    beforeEach(async function () {
      await contract.registerUser(1);
      await contract.registerUser(2);
      await contract.addContact(1, 2);
    });

    it("Should handle various depth levels in computation", async function () {
      // Test with different depth values to ensure no overflow/underflow
      const depths = [0, 1, 2, 5, 10, 20, 50];
      
      for (const depth of depths) {
        await expect(contract.computeIVS(depth))
          .to.emit(contract, "IVSComputed")
          .withArgs(depth);
      }
    });

    it("Should handle maximum depth gracefully", async function () {
      // Test with very large depth to check overflow protection
      await expect(contract.computeIVS(255))
        .to.emit(contract, "IVSComputed")
        .withArgs(255);
    });
  });

  describe("Event Emission", function () {
    it("Should emit all expected events during normal operations", async function () {
      // User registration
      await expect(contract.registerUser(1))
        .to.emit(contract, "UserRegistered")
        .withArgs(1);
      
      await contract.registerUser(2);
      
      // Contact addition
      await expect(contract.addContact(1, 2))
        .to.emit(contract, "ContactAdded")
        .withArgs(1, 2);
      
      // IVS computation
      await expect(contract.computeIVS(2))
        .to.emit(contract, "IVSComputed")
        .withArgs(2);
      
      // Decryption request
      const tx = await contract.getDecryptedIVS(1);
      const receipt = await tx.wait();
      
      const decryptionEvents = receipt!.logs.filter(log => {
        try {
          const parsed = contract.interface.parseLog(log);
          return parsed?.name === 'DecryptionRequested';
        } catch {
          return false;
        }
      });
      
      expect(decryptionEvents.length).to.equal(1);
      
      // User deletion
      await expect(contract.deleteUser(1))
        .to.emit(contract, "UserDeleted")
        .withArgs(1);
      
      // Data wipe
      await expect(contract.wipeAllData())
        .to.emit(contract, "AllDataWiped");
    });
  });

  describe("Gas Usage Optimization", function () {
    it("Should have reasonable gas costs for operations", async function () {
      // Test gas usage for various operations
      const registerTx = await contract.registerUser(1);
      const registerReceipt = await registerTx.wait();
      console.log(`User registration gas used: ${registerReceipt!.gasUsed}`);
      
      await contract.registerUser(2);
      
      const contactTx = await contract.addContact(1, 2);
      const contactReceipt = await contactTx.wait();
      console.log(`Add contact gas used: ${contactReceipt!.gasUsed}`);
      
      const computeTx = await contract.computeIVS(2);
      const computeReceipt = await computeTx.wait();
      console.log(`IVS computation gas used: ${computeReceipt!.gasUsed}`);
      
      // Basic checks that operations don't exceed reasonable gas limits
      expect(registerReceipt!.gasUsed).to.be.lessThan(250000n);
      expect(contactReceipt!.gasUsed).to.be.lessThan(150000n);
      // IVS computation may use more gas due to FHE operations
      expect(computeReceipt!.gasUsed).to.be.lessThan(1000000n);
    });
  });
});